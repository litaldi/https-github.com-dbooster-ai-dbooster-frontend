
import { Meta } from '@storybook/blocks';

<Meta title="Design System/Component Guidelines" />

# Component Guidelines

Best practices and patterns for building consistent, accessible, and maintainable components in the DBooster design system.

## ðŸŽ¯ Design Principles

### 1. Accessibility First
- **WCAG 2.1 AAA Compliance**: All components meet the highest accessibility standards
- **Keyboard Navigation**: Full keyboard support with logical tab order
- **Screen Reader Support**: Proper ARIA labels and semantic HTML
- **Focus Management**: Visible focus indicators and focus trapping where appropriate

### 2. Mobile-First Design
- **Responsive by Default**: Components work seamlessly across all screen sizes
- **Touch-Friendly**: Minimum 44px touch targets for interactive elements
- **Progressive Enhancement**: Enhanced experiences on larger screens

### 3. Performance Optimized
- **Lazy Loading**: Components load only when needed
- **Tree-Shakeable**: Import only what you use
- **Minimal Bundle Impact**: Optimized for production builds

## ðŸ§© Component Architecture

### Component Types

#### 1. Primitive Components
Basic building blocks with minimal styling and maximum flexibility.

```tsx
// Example: Enhanced Button
<EnhancedButton variant="primary" size="lg">
  Click me
</EnhancedButton>
```

#### 2. Composite Components
Complex components built from primitives with specific use cases.

```tsx
// Example: Enhanced Hero Section
<EnhancedHero
  title="Transform Your Database"
  description="AI-powered optimization for enterprise databases"
  primaryCTA={{ text: "Get Started", onClick: handleClick }}
/>
```

#### 3. Layout Components
Structural components for consistent spacing and organization.

```tsx
// Example: Visual Hierarchy
<Section spacing="xl">
  <Container size="lg">
    <Heading level={1} size="3xl">Page Title</Heading>
    <Text size="lg" variant="muted">Description</Text>
  </Container>
</Section>
```

### Component API Design

#### Consistent Props Pattern
```tsx
interface ComponentProps {
  // Visual variants
  variant?: 'primary' | 'secondary' | 'outline';
  size?: 'sm' | 'md' | 'lg';
  
  // Behavior
  disabled?: boolean;
  loading?: boolean;
  
  // Content
  children?: React.ReactNode;
  
  // Accessibility
  'aria-label'?: string;
  
  // Standard HTML props
  className?: string;
}
```

#### Compound Components
For complex UI patterns, use compound component patterns:

```tsx
<AccessibilityMenu>
  <AccessibilityMenu.Header>
    <AccessibilityMenu.Title>Settings</AccessibilityMenu.Title>
    <AccessibilityMenu.CloseButton />
  </AccessibilityMenu.Header>
  <AccessibilityMenu.Content>
    <AccessibilityMenu.Toggle>High Contrast</AccessibilityMenu.Toggle>
  </AccessibilityMenu.Content>
</AccessibilityMenu>
```

## ðŸŽ¨ Styling Guidelines

### 1. Tailwind CSS Classes
Use utility-first approach with consistent patterns:

```tsx
// Good: Consistent spacing and responsive design
className="px-4 py-2 sm:px-6 sm:py-3 lg:px-8 lg:py-4"

// Avoid: Magic numbers or inconsistent spacing
className="px-5 py-3 sm:px-7 sm:py-4"
```

### 2. CSS Custom Properties
Use design tokens for consistent theming:

```css
.component {
  background: hsl(var(--primary));
  color: hsl(var(--primary-foreground));
  border-radius: var(--radius);
}
```

### 3. Responsive Design
Mobile-first breakpoints:

```tsx
// Mobile: base styles
// Tablet: sm: prefix (640px+)
// Desktop: lg: prefix (1024px+)
// Large: xl: prefix (1280px+)

className="text-sm sm:text-base lg:text-lg xl:text-xl"
```

## â™¿ Accessibility Patterns

### 1. Semantic HTML
Always use appropriate HTML elements:

```tsx
// Good: Semantic button
<button type="button" onClick={handleClick}>
  Submit
</button>

// Avoid: Div as button
<div onClick={handleClick} className="button-styles">
  Submit
</div>
```

### 2. ARIA Labels
Provide context for screen readers:

```tsx
<button
  aria-label="Close dialog"
  aria-expanded="false"
  aria-controls="dialog-content"
>
  <X className="h-4 w-4" />
</button>
```

### 3. Focus Management
Implement proper focus handling:

```tsx
// Focus trapping in modals
const { containerRef } = useFocusManagement(isOpen, {
  trapFocus: true,
  restoreFocus: true
});
```

### 4. Keyboard Navigation
Support all keyboard interactions:

```tsx
const handleKeyDown = (e: KeyboardEvent) => {
  switch (e.key) {
    case 'Escape':
      onClose();
      break;
    case 'Tab':
      handleTabNavigation(e);
      break;
  }
};
```

## ðŸ§ª Testing Guidelines

### 1. Unit Tests
Test component logic and rendering:

```tsx
describe('EnhancedButton', () => {
  it('renders with correct variant styles', () => {
    render(<EnhancedButton variant="primary">Click me</EnhancedButton>);
    expect(screen.getByRole('button')).toHaveClass('bg-primary');
  });

  it('handles loading state correctly', () => {
    render(<EnhancedButton loading>Submit</EnhancedButton>);
    expect(screen.getByRole('button')).toBeDisabled();
    expect(screen.getByText('Loading...')).toBeInTheDocument();
  });
});
```

### 2. Accessibility Tests
Automated accessibility testing:

```tsx
import { axe, toHaveNoViolations } from 'jest-axe';

expect.extend(toHaveNoViolations);

test('component is accessible', async () => {
  const { container } = render(<Component />);
  const results = await axe(container);
  expect(results).toHaveNoViolations();
});
```

### 3. Visual Regression Tests
Storybook + Chromatic integration for UI consistency.

## ðŸ“± Responsive Design Patterns

### 1. Breakpoint Strategy
```scss
// Mobile First Approach
.component {
  // Mobile styles (default)
  padding: 1rem;
  
  // Tablet (640px+)
  @media (min-width: 640px) {
    padding: 1.5rem;
  }
  
  // Desktop (1024px+)
  @media (min-width: 1024px) {
    padding: 2rem;
  }
}
```

### 2. Container Queries
For component-based responsive design:

```tsx
<div className="container-lg">
  <div className="@lg:grid-cols-2 @xl:grid-cols-3">
    {/* Content adapts to container size */}
  </div>
</div>
```

## ðŸš€ Performance Best Practices

### 1. Lazy Loading
```tsx
const HeavyComponent = lazy(() => import('./HeavyComponent'));

function App() {
  return (
    <Suspense fallback={<Loading />}>
      <HeavyComponent />
    </Suspense>
  );
}
```

### 2. Memoization
```tsx
const ExpensiveComponent = memo(({ data }) => {
  const processedData = useMemo(() => 
    processData(data), [data]
  );
  
  return <div>{processedData}</div>;
});
```

### 3. Bundle Optimization
- Tree-shake unused code
- Use dynamic imports for large dependencies
- Optimize images with proper formats (WebP, AVIF)

## ðŸ“– Documentation Standards

### 1. Component Stories
Every component should have comprehensive Storybook stories:

```tsx
export default {
  title: 'Components/Button',
  component: Button,
  parameters: {
    docs: {
      description: {
        component: 'A flexible button component with multiple variants.'
      }
    }
  }
};

export const Primary = {
  args: {
    variant: 'primary',
    children: 'Primary Button'
  }
};
```

### 2. TypeScript Documentation
```tsx
/**
 * Enhanced button component with loading states and accessibility features
 * 
 * @example
 * <EnhancedButton variant="primary" loading>
 *   Submit Form
 * </EnhancedButton>
 */
interface EnhancedButtonProps {
  /** Button visual variant */
  variant?: 'primary' | 'secondary' | 'outline';
  /** Show loading spinner and disable button */
  loading?: boolean;
  /** Button content */
  children: React.ReactNode;
}
```

## ðŸ”§ Development Workflow

### 1. Component Development Process
1. **Design Review**: Ensure component meets design requirements
2. **Accessibility Audit**: Verify WCAG compliance
3. **Implementation**: Build with TypeScript and Tailwind
4. **Testing**: Unit tests, accessibility tests, visual tests
5. **Documentation**: Storybook stories and TypeScript docs
6. **Review**: Code review focusing on API design and accessibility

### 2. Version Control
- Use semantic commits
- Include accessibility impact in commit messages
- Test accessibility before every commit

By following these guidelines, we ensure that every component in the DBooster design system is consistent, accessible, performant, and maintainable.
